<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作用域</title>
</head>
<body>
    <script>
        /* 
            作用域：一个变量的可用范围
                全局作用域：在全局作用域内声明的变量叫全局变量
                局部作用域/函数作用域： 在局部作用域(函数内声明)声明的变量叫局部变量，函数的参数也是局部变量
                块级作用域（ES6 中）: 使用 let 声明的变量，只在对应的块级作用域中生效，对于嵌套的块级作用域，内层的块级作用域可以使用外层的块级作用域变量，外层的作用域不能使用内层作用域的变量。(需要注意的是 块级作用域针对的变量是使用 let 进行声明的， 对于使用 var 声明的变量并不存在块级作用域的规则。 var 声明的变量作用域只有全局作用域和局部作用域)

            对于未声明的变量直接赋值， js 会在全局作用域自动地帮你声明。

            变量声明提升：该变量会自动提升到当前作用域的最顶部

            对于同一个语句，自动声明和变量声明提升是同时存在的吗？答案是否定的，如果有变量提升，说明这个语句的变量已经且只能是使用了 var 进行声明，就自然不存在自动声明这一说法了。 如果有自动声明，自动声明会自动的在全局作用域声明，因此也用不着进行变量声明提升了。

        */
        /* 1.// 对于未声明的变量直接赋值， js 会自动在全局作用域帮你声明。即使是在函数的内部
            function a(){
                x = 1;
            }
            a();  // 这一步是执行函数，不可缺少的，不执行这个函数的话，x 相当于没有在函数中初始化操作。
            console.log(x);  // 1
        */

        /* 
            2.// 始终记得执行的顺序是按顺序执行的，但是要记得 
                1.自动声明始终是提升到全局作用域（没有声明，直接赋值的语句就会自动声明）
                2.函数提升是整体提升
                3.变量声明提升是将声明提升到当前作用域的最顶部
                总结起来就是要当心声明语句，和没有声明就直接赋值的语句，在其他语句之后的时候要注意可能会改变整体的执行顺序，看起来和代码的执行顺序不一样。执行的结果也会出现差异
            2.1// 变量声明提升：自动提升到当前作用域的最顶部
            var x = 5;
            function a(){
                console.log(x);  // undefined
                var x = 100;  // 变量声明提升：自动提升到当前作用域的最顶部,只是声明提前，赋值并没有提前
            }
            a();

            var x = 5;
            console.log(x);  //5
                function a(){
                    console.log(x);  // undefined
                    var x = 100;  // 变量声明提升：自动提升到当前作用域的最顶部,只是声明提前，赋值并没有提前
                }
            a();
            console.log(x);  //5
        

            2.2// 当存在全局变量和局部变量的时候，优先使用自己的局部变量
            var x = 5;
            function a(){
                var x = 100;  
                console.log(x);  // 100
            }
            a();

            var x = 5;
            console.log(x);   // 5
                function a(){
                    var x = 100;  
                    console.log(x);  // 100
                }
            a();
            console.log(x);  // 5

           2.3 // 产生覆盖的情形
            var x = 5;
            console.log(x);   //5
            function a(){
                x = 100;    // 没有声明，直接赋值，会提升到全局作用域声明。然后产生覆盖。
                console.log(x);  // 100
            }
            a();
            console.log(x);   //100
        
        */
        
        
            // 3.// 注意当声明语句和赋值语句在其他的语句之后时，变量的提升和 js 的自动声明 会改变代码的运行顺序，使得结果发生变化
       /*  var a = 5;
        function fn(){
            console.log(a);   // undefined  
            a = 8;
            var a;    // 这里进行了声明，所以这里的 a 是局部变量，变量提升到当前作用域的最顶部。
            console.log(a);   // 8   

        }
        fn();
        a++;
        console.log(a);  // 6    */
       

        /* var a = 5;
        function fn(){
            console.log(a);     //5
            a = 8;
            // var a;    // 与上面不同的是这里注释了函数内部变量 a 的声明，所以在这里的 a 就成了全局变量。
            console.log(a);    //8

        }
        fn();
        a++;
        console.log(a);    //9 */
       

    
        
        
       
        /* console.log(a);  //变量 a 没有在任何地方声明而是直接赋值的，为什么没有提升到全局作用域呢  // 为什么这里不对啊 不是 undefined。 因为这里的声明语句在函数内部，函数还没有调用，所以相当于不存在 a 这个声明语句，所以才会返回错误的结果是 a 没有声明。
        function fn(){
            a=10;
            console.log(a);   
        }
        fn(); */
        

        
           /*  // 先调用函数，再打印，这里直接赋值，没有声明的变量 a 就成了全局变量，浏览器自动帮助声明的。所以最后在全局打印的结果也是 10了
           
        var fn = function(){
            a=10;
            console.log(a);    // 10
        }
        fn();
        console.log(a);    // 10 */

       


    </script>
</body>
</html>