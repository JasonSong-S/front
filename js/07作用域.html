<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作用域</title>
</head>
<body>
    <script>
        /* 
            作用域：一个变量的可用范围
                全局作用域：在全局作用域内声明的变量叫全局变量
                局部作用域/函数作用域： 在局部作用域声明的变量叫局部变量

            对于未声明的变量直接赋值， js 会自动在全局作用域帮你声明。

            变量声明提升：自动提升到当前作用域的最顶部

        */
        /* 1.// 对于未声明的变量直接赋值， js 会自动在全局作用域帮你声明。即使是在函数的内部
            function a(){
                x = 1;
            }
            a();  // 这一步是执行函数，不可缺少的，不执行这个函数的话，x 相当于没有在函数中初始化操作。
            console.log(x);  // 1
        */

        /* 
            2.// 始终记得执行的顺序是按顺序执行的，但是要记得 
                1.自动声明始终是提升到全局作用域（没有声明，直接赋值的语句就会自动声明）
                2.函数提升整体提升
                3.变量提升到当前作用域的最顶部
                总结起来就是要当心声明语句和没有声明就直接赋值的语句在其他语句之后的时候要注意可能会改变整体的执行顺序，看起来和代码的执行顺序不一样。执行的结果也会出现差异
            2.1// 变量声明提升：自动提升到当前作用域的最顶部
            var x = 5;
            function a(){
                console.log(x);  // undefined
                var x = 100;  // 变量声明提升：自动提升到当前作用域的最顶部,只是声明提前，赋值并没有提前
            }
            a();

            var x = 5;
            console.log(x);  //5
                function a(){
                    console.log(x);  // undefined
                    var x = 100;  // 变量声明提升：自动提升到当前作用域的最顶部,只是声明提前，赋值并没有提前
                }
            a();
            console.log(x);  //5
        

            2.2// 当存在全局变量和局部变量的时候，优先使用自己的局部变量
            var x = 5;
            function a(){
                var x = 100;  
                console.log(x);  // 100
            }
            a();

            var x = 5;
            console.log(x);   // 5
                function a(){
                    var x = 100;  
                    console.log(x);  // 100
                }
            a();
            console.log(x);  // 5

           2.3 // 产生覆盖的情形
            var x = 5;
            console.log(x);   //5
            function a(){
                x = 100;    // 没有声明，直接赋值，会提升到全局作用域声明。然后产生覆盖。
                console.log(x);  // 100
            }
            a();
            console.log(x);   //100
        
        */
        
        /*    // 3.// 注意当声明语句和赋值语句在其他的语句之后时，变量的提升和 js 的自动声明 会改变代码的运行顺序，使得结果发生变化
        var a = 5;
        function fn(){
            console.log(a);   // undefined  
            a = 8;
            var a;    // 这里进行了声明，所以这里的 a 是局部变量，变量提升到当前作用域的最顶部。
            console.log(a);   // 8   

        }
        fn();
        a++;
        console.log(a);  // 6   */ 
       

        /* var a = 5;
        function fn(){
            console.log(a);     //5
            a = 8;
            // var a;    // 与上面不同的是这里注释了函数内部变量 a 的声明，所以在这里的 a 就成了全局变量。
            console.log(a);    //8

        }
        fn();
        a++;
        console.log(a);    //9 */
       

    
        
        
       
        /* console.log(a);  //变量 a 没有在任何地方声明而是直接赋值的，为什么没有提升到全局作用域呢  // 为什么这里不对啊 不是 undefined。 因为这里的声明语句在函数内部，函数还没有调用，所以相当于不存在 a 这个声明语句，所以才会返回错误的结果是 a 没有声明。
        function fn(){
            a=10;
            console.log(a);   // 返回 变量 a 没有声明，函数运行错误
        }
        fn(); */
         

        /* 
            // 先调用函数，再打印，这里直接赋值，没有声明的变量 a 就成了全局变量，浏览器自动帮助声明的。所以最后在全局打印的结果也是 10了
        var fn = function(){
            a=10;
            console.log(a);    // 10
        }
        fn();
        console.log(a);    // 10 */


    </script>
</body>
</html>