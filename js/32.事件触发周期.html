<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*  0. 事件： 事件是在你正在编程的系统内发生的操作或者事件。当事件发生时，系统会触发某种信号，并提供一种机制，通过该机制，可以在事件发生时自动执行某些操作。
                1.通过事件处理程序去对事件做出反应 
                2.事件处理对象元素.on事件名 和  事件处理对象元素.addEventListner("事件名"， 函数，是否在捕获阶段触发)的区别 
                    事件处理对象元素.on事件名 又叫做事件处理程序属性，如果是同一个事件的话，后面的属性会覆盖前面的属性，所以通过这种方式最多只能有一个同一个类型的事件处理函数会起作用。比如 button.onclick = fn;  button.onclick = fn2;只有后面的这个会起作用，前面的会被覆盖掉。
                    事件处理对象元素.addEventListner("事件名"， 函数，是否在捕获阶段触发) 可以对同一个事件添加多个处理函数，他们会同时的起作用，比如 button.addEventListner('click',fn);   button.addEventListner('click',fn2); 这两个都会起作用，不会产生后覆盖前的情况。同时可以通过 removeEventListner('事件名'，事件处理函数) 来移除事件
                    要注意的一点是  通过函数声明并给与引用的函数，和直接写在 addEventListner()内部，即使他们的函数体一样，他们也不是同一个函数。


            1.事件触发周期：
                事件捕获，目标触发，事件冒泡发生在元素嵌套在元素内部的情况。元素具有父元素
                事件捕获： 从外向里做标记，直到该元素的直接父元素为止。
                目标触发： 运行事件处理程序，如果 bubble 为真，他会传递事件到到他的直接父元素，这样循环直至最外层。如果 bubble 为假，他会停止传递事件到他的直接父元素及其更外层
                事件冒泡： 从里向外返回 ， 浏览器检查被单击元素的直接父元素是否有事件处理程序，如果有就运行它，直到最外层。

            2. 事件处理对象元素.addEventListner("事件名"， 函数，是否在捕获阶段触发)
                事件处理函数 = on + 事件名

            3. 事件冒泡的缺点是，在到达我们指定的元素之前，它必然会经过它的父元素，但是我们并不希望在它的父元素上有任何的操作。为了消除这个影响，可以使用 e.stopPropagation() 方法阻止冒泡。但是事件冒泡也有有用的一面，就是事件代理的使用。
            3. 事件代理： 有时候子元素的个数不确定，甚至都没有进行渲染，我们不能直接在目标元素上绑定事件。这时候我们可以通过事件代理的方式，在父元素上绑定之后通过冒泡的方式让子元素获得事件处理函数。


            
        
        */



    </script>
</body>
</html>