<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>函数</title>
</head>
<body>
    <script>
        /* 
            函数:封装一段执行专门任务的代码段。定义函数有两种方式
                方式一： 使用 function 关键字进行声明函数
                
                    function 函数名(参数){
                            你要做得事
                         }  通过 function 关键字来声明函数
                另外一种定义函数的方式：函数表达式（函数表达式中函数可以有名字，也可以没有名字）
                    var fn = function 函数名(参数){你要做得事}  通过变量的方式来定义函数
                    var fn = function (参数){你要做得事}  通过变量的方式来定义函数
                
                这两种定义的方式推荐使用方式一的通过 function 关键字来声明函数。并且这两种方式会有不同的地方
            比如，在声明提前的时候， function 来声明的函数，会让整体都提前。通过 var + 变量 来声明的函数，只会让
            变量的声明提前。但是在需要将函数作为一个参数传入的时候，推荐使用函数表达式。

                1. 函数不调用，不执行
                2. 函数的调用，函数名()
                3. 参数：函数内独有的变量，让函数更灵活，不需要声明。另外，在函数外无权调用。
                    形参：形式上的参数，函数定义的时候
                    实参：实际的参数，函数调用的时候 
                    注意：也可分为显示参数和隐式参数
                    显示参数：函数定义的时候的参数
                    隐式参数：函数调用的时候实际传入的参数，可以使用关键字 arguments 来查看, arguments 是一个类似数组的对象，可以利用角标访问，但是没有数组的方法
                4. 函数提升 整体提升（使用 function 声明的函数会整体提升，因此可以在 js 中任何地方访问函数。
                5. 函数是个纯过程，没有结果
                6. return 单个不带值，退出函数运行
                    如果在 return 的后面跟一个值，那么就会在函数退出的同时，返回一个结果。
                7. 匿名函数形式 function(参数){你要做得事} 没有函数名称，也没有通过变量的方式来声明函数
                8. 匿名函数也叫函数表达式。函数表达式与函数声明有一些区别，函数声明会进行声明提升，但是函数表达式并不会
                9. 函数内部定义的变量称为局部变量，局部变量只能在该函数内部进行访问。函数外部无权访问局部变量。
                10. 全局变量可以在脚本内任何地方被访问。
                11. 可以在任何地方调用函数，甚至可以在函数的内部调用函数。这是因为函数会提升
                12. 函数名和变量名不能重名，因为函数就是一种特殊的变量。调用的时候不知道是调用的函数，还是变量的值了。
                13. 全局变量会在页面关闭之后被删除
                14. 局部变量会在函数执行完毕之后被删除
                15. 关于分号(;)：分号在 js 是用来分隔可执行语句的，因为函数的声明不是可执行语句，所以函数声明的结束没有分号结尾。
        */
        /* 
            注意： 在这里的几个函数都是在同一个作用域声明的，所以 a() b() output() 这三个函数属于同一个级别，并不是闭包结构，闭包结构外层是父函数，内层是子函数。子函数在父函数内声明的。所以在这里他们不会该变外层函数变量的值。

            形参和实参的联系：
                值传递的时候，形参和实参是不同的变量，形参只是将实参的值复制了一份，所以形参值的改变不会影响到实参的值
                引用传递的时候，形参复制的是实参的地址，复制的地址并不会改变，因为形参和实参使用的同一个地址，它们指向了同一个对象实体，所以形参的值的改变也会影响到实参的值。
          
          */

          const x = 1;

            function a() {
                const y = 2;
                output(y);
                
            }
            let c = 10;
            function b() {
                const z = 3; 
                output(c);
                console.log("c的值"+c);
                console.log(output(z));
            }

            function output(value) {
                const  para = document.createElement('p');
                document.body.appendChild(para);
                value=value*value;
                console.log("value的值"+value);
                para.textContent = `Value: ${value}`;
                return 'over';    // 为什么在 b函数 中调用时,这句不执行呢？ 答案是执行了的，但是它的结果需要一个变量来接收并打印出来，也可以直接打印，需要用到 console.log()
            }
            b();
    </script>
</body>
</html>