<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>闭包</title>
</head>
<body>
    <script>
        /* 
            0. 闭包：函数内套函数，并且内层的函数是在外层的函数体内进行声明的，内层的函数使用了外层函数的局部变量。
            1.在 web 中，全局变量属于 windows 对象
            2.全局变量可以应用于页面中所有的脚本
            3.局部变量只能用于定义它函数的内部，对于其他的函数或脚本代码是不可用的
            4.全局变量和局部变量即便名称相同，他们也是两个不同的变量（可能是因为他们的作用域不一样），修改其中一个，不会影响另一个的值
            5.变量声明时如果不使用 var 关键字， 那么它就是一个全局变量，即便它在函数内定义。
            6.所有函数都能访问全局变量
            7.嵌套函数可以访问外层的函数变量
            8.垃圾回收在闭包中的使用，在 js 中，全局变量永远不会回收的，因为全局变量可以在脚本内的任何一个地方使用到，所以太多的全局变量会占用比较多的内存。另外，过多的闭包也会造成内存泄漏，因为使用闭包的方式需要将返回的函数赋值给一个全局变量，这样因为有全局变量再使用这个函数，所以函数的作用域不会被释放，多次调用才可以在之前的基础上进行运算。如果并没有将闭包返回的函数赋值给一个全局变量，而是直接使用两个括号来调用的话，得到的都是调用一次的结果，并不会在之前的基础上进行运算。因为函数作用域作为局部作用域，在调用一次后，因为没有地方在使用了，所以会被垃圾回收掉，每次调用就是重新开始进行运算。
            9.局部作用域不会一直占用内存空间。因为局部作用域在函数调用的时候才会进行创建，函数执行结束之后就会被释放。
            10. 闭包的结构是：函数内套函数，这两个函数之间是父子关系的才算，意思外层是一个函数，内层的函数是在外层函数内进行的声明。这样才算是闭包的函数套函数。  易错的地方在于，外层的函数和内层的函数属于同级的关系，都是在一个作用域进行的声明，但是在外层函数内调用了同级的内层函数，这样的结构不是闭包结构的函数套函数。
        */

        /* // 闭包结构可以改变外层函数的值
        function getNum(){
            var n = 0;
            function add(){
             return n++;
            }
            return add;
        };
        var c=getNum();
        console.log(c());   // 0 
        console.log(c());   // 1
        console.log(c());   // 2  */

    /* function a(){
        var name = "div";
        return function(){
            return name;
        }
    }

    var b = a();
    console.log(b()); */

    /* function fn(){
        var num=3;
        return function(){
            var n=0;
            console.log(n++);
            console.log(++num);

        }
    }

    var fn1 = fn();
    fn1();  // 0 4
    fn1();  // 0 5 */


    /* function fn(){
        var num=3;
        function a(){
            var n=0;
            console.log(n++);
            console.log(++num);
        }
        return a;
    }
    //结果不一样呢？ 这是因为第一种方式在全局声明了一个全局变量来接收闭包结构的结果，全局变量的空间在脚本内是不会被自动释放的，除非关闭浏览器。所以多次调用的时候，后面的调用是在前一次的基础上进行运算的。而直接加括号来调用的话，因为是局部作用域，每次调用结束后，局部作用域都会被释放掉，所以每次都是从最开始执行的，没有之前运行的基础。
    // 第一种方式设置引用，可以改变外层函数的值
    // var fn1 = fn();
    // fn1();  // 0 4
    // fn1();  // 0 5
    // 第二种方式，直接加括号来调用，不能改变外层函数的值，每次都是从最开始运行。
    // fn()();  // 0 4
    // fn()();  // 0 4 */


    /* function init(){
        var n=100;
        console.log("外部"+n);
        function display(){
            var num=0;
            console.log(n++);
            console.log(num++);
        }
        return display;
    }
    // 注意这两种方式执行两次的结果不一样
    // 第一种
    // init();  //外部100 100 0  
    // init();  //外部100 100 0  
    // 第二种
    // var c = init();  // 外部100
    // c();  // 100 0
    // c();  // 101 0 */
    </script>
</body>
</html>